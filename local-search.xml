<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>vite2-另类的自定义base</title>
    <link href="/2022/07/02/vite/vite2-%E5%8F%A6%E7%B1%BB%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89base/"/>
    <url>/2022/07/02/vite/vite2-%E5%8F%A6%E7%B1%BB%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89base/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>构建工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vite</tag>
      
      <tag>构建工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nodejs扩展学习笔记(Windows)</title>
    <link href="/2016/08/14/nodejs%E6%89%A9%E5%B1%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Windows/"/>
    <url>/2016/08/14/nodejs%E6%89%A9%E5%B1%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Windows/</url>
    
    <content type="html"><![CDATA[<h5 id="最近着手开始学习nodejs扩展的开发，是为以后用electron-electron项目主页-做客户端打个基础，也是为了熟悉js如何与C-交互，客户端的话可能需要用到C-的一些东西，因此这里选择在windows下搭建开发环境，nodejs-版本为4-x。"><a href="#最近着手开始学习nodejs扩展的开发，是为以后用electron-electron项目主页-做客户端打个基础，也是为了熟悉js如何与C-交互，客户端的话可能需要用到C-的一些东西，因此这里选择在windows下搭建开发环境，nodejs-版本为4-x。" class="headerlink" title="最近着手开始学习nodejs扩展的开发，是为以后用electron (electron项目主页) 做客户端打个基础，也是为了熟悉js如何与C++交互，客户端的话可能需要用到C++的一些东西，因此这里选择在windows下搭建开发环境，nodejs 版本为4.x。"></a>最近着手开始学习nodejs扩展的开发，是为以后用electron (<a href="http://electron.atom.io/">electron项目主页</a>) 做客户端打个基础，也是为了熟悉js如何与<code>C++</code>交互，客户端的话可能需要用到<code>C++</code>的一些东西，因此这里选择在windows下搭建开发环境，nodejs 版本为4.x。</h5><h3 id="一、windows下nodejs-addon-环境的搭建"><a href="#一、windows下nodejs-addon-环境的搭建" class="headerlink" title="一、windows下nodejs addon 环境的搭建"></a>一、windows下nodejs addon 环境的搭建</h3><ul><li>VC++ 的开发先装个visual studio吧，装个Visual Studio 2015就好了，接下来就是漫长的安装过程。</li><li>装完之后找到<code>MSBuild\14.0\Bin</code>，一般在<code>C:\Program Files (x86)</code>中，把这个路径配到环境变量里，这样可以用命令行调用 MSBuild.exe对visual stdio 的工程文件 <code>.sln</code>进行编译。</li><li>安装cmake 这里没有使用node-gyp进行构建，其实两个的道理一样都是生成VS工程文件然后用VC的工具链进行构建，但是适用性更广泛一些。</li><li>下载nodejs 4.x源码，这一步要进行源码编译，命令行下执行vcbuild.bat进行debug 32位版本nodejs的编译，具体是参考这篇老外的文章<br><a href="http://computer-vision-talks.com/how-to-debug-nodejs-addons-in-visual-studio/">http://computer-vision-talks.com/how-to-debug-nodejs-addons-in-visual-studio/</a><br>在这里也可以找到如何在vs下对扩展进行调试，亲测。</li></ul><hr><h3 id="二、cmake的编写"><a href="#二、cmake的编写" class="headerlink" title="二、cmake的编写"></a>二、cmake的编写</h3>]]></content>
    
    
    <categories>
      
      <category>Nodejs扩展</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nodejs</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react动画实践</title>
    <link href="/2016/07/02/react%E5%8A%A8%E7%94%BB%E5%AE%9E%E8%B7%B5/"/>
    <url>/2016/07/02/react%E5%8A%A8%E7%94%BB%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="React-动画实践"><a href="#React-动画实践" class="headerlink" title="React 动画实践"></a>React 动画实践</h3><h4 id="ReactTransitionGroup使用"><a href="#ReactTransitionGroup使用" class="headerlink" title="ReactTransitionGroup使用"></a>ReactTransitionGroup使用</h4><ul><li>ReactTransitionGroup 必须是已经被挂载的组件，例如:<pre><code class="hljs">  let Component=React.createClass(&#123;      render()&#123;          return &lt;ReactTransitionGroup&gt;              [children]          &lt;/ReactTransitionGroup&gt;      &#125;  &#125;);        </code></pre></li><li>children 组件上必须要有key才能触发React的动画，例如:<pre><code class="hljs">  let ListItem = React.createClass(&#123;  componentWillEnter(done)&#123;      console.log(&#39;ListItem will enter&#39;);      done();  &#125;,  render()&#123;      return (          &lt;div&gt;&#123;this.props.children&#125;&lt;/div&gt;      );    &#125;  &#125;);  let View=React.createClass(&#123;      render()&#123;           let list = this.state.items.map((item, index)=&gt; &#123;              return &lt;ListItem key=&#123;index&#125;&gt;&#123;item.text&#125;&lt;/ListItem&gt;          &#125;);      &#125;  &#125;);</code></pre> 当某个时刻View内调用setState后将会触发渲染，ReactTransitionGroup 会比对当前状态的key和下个状态的key并会在新增的key上<br> 触发ListItem的componentWillEnter 生命周期。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>组件只要放在ReactTransitionGroup内并且key是变动的就会触发动画。</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>框架</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack学习笔记(1)</title>
    <link href="/2015/09/13/webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/"/>
    <url>/2015/09/13/webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>构建工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vuejs 0.12.x学习笔记——组件中数据继承</title>
    <link href="/2015/07/19/Vuejs-0-12-x%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E7%BB%84%E4%BB%B6%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%BB%A7%E6%89%BF/"/>
    <url>/2015/07/19/Vuejs-0-12-x%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E7%BB%84%E4%BB%B6%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<p>Vuejs 0.12.x 在组件系统的Api上有些变化，首先是v-with 这个指令没有了，取而代之的是需要通过props来向子组件传递父组件或ViewModel的数据，例如:    </p><div id="component-demo"><user-profile user-profile="{{userProfile}}" title={{title}} v-ref="userProfile"></user-profile></div><script>var vm=new Vue({        el:'#component-demo',        data:{            'title':'',            'userProfile':'dp'        },        components:{            'user-profile':{                template:'<h1>{{title}}</h1><p>{{userProfile}}</p>',                props:['title','userProfile']            }        }    });</script><p>通过直接在标签上添加属性，在Mustache标签里添加父ViewModel的数据，在子组件props数组当中加入标签上属性的名字来继承数据，<strong>注意当标签属性名当中出现了’-‘时，在props里要写成驼峰的形式并且在使用这个数据的地方都要写成驼峰模式。在props当中出现的名字会被添加到数据上</strong></p><p>#####上面的props的类型是数组，下面会说明props为对象时的情况</p> var vm=new Vue({        el:'#component-demo',        data:{            'title':'',            'userProfile':'dp'        },        components:{            'user-profile':{                template:'<h1>{{title}}</h1><p>{{userProfile}}</p>',                props:{                    title:{                        type:String                    }                }            }        }    });<p><code>props</code> 的<code>title</code> 属性，键名就是从父类继承的数据的名称，<code>title</code>的值是一个对象，里面的<code>type</code> 属性值为<code>String</code> 这表示子组件上的<code>title</code>数据只能从父类继承<code>String</code> 类型的数据，<br>当父ViewModel设置的<code>title</code>数据类型与子组件所规定的不符，则子组件的<code>title</code>不会被设置。</p><p>以下下几点要注意:</p><ul><li>当在标签上加上<code>title</code>属性后,如果父ViewModel初始化的<code>title</code>的数据类型与子组件<code>title</code>不符，那么子组件此时不会有<code>title</code>这个数据存在。</li><li>当标签上无<code>title</code>属性时，如果<code>props</code>对象里或当<code>props</code>数组里有<code>title</code>，此时在子组件上会有<code>title</code>数据，不会受父级影响</li><li>对于子组件设置<code>title</code>是不受类型约束的。 </li></ul>]]></content>
    
    
    <categories>
      
      <category>前端框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MVVM</tag>
      
      <tag>前端框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Yeoman学习笔记(一) InquirerJs 学习</title>
    <link href="/2015/05/11/Yeoman%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/"/>
    <url>/2015/05/11/Yeoman%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<p>最近想用Yeoman这个脚手架做一个自己平常用的项目生成器,项目地址：<a href="http://yeoman.io/" title="项目地址">http://yeoman.io/</a>。<br>阅读了一部分开发文档，当看到user interaction 这一节的时候，yeoman用到了prompt，并且这个prompt是用的InquirerJs 提供的，因此需要大致了解一下，github地址：<a href="https://github.com/SBoudrias/Inquirer.js">https://github.com/SBoudrias/Inquirer.js</a>，这是一个prompt的库，用起来很方便，上面的文档很详细，还有例子，下面是写了一个demo，来实例展示一下如何使用。</p><h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><pre><code class="hljs">npm install inquirer --save</code></pre><h2 id="二、开始编写代码"><a href="#二、开始编写代码" class="headerlink" title="二、开始编写代码"></a>二、开始编写代码</h2><pre><code class="hljs">var inquirer=require(&#39;inquirer&#39;);inquirer.prompt([&#123;    type:&#39;input&#39;,    name:&#39;firstName&#39;,    message:function(answer)&#123;        console.log(answer);   //这里的answer就是文档中所说的Anwser对象，                              //当输入了之后，这对象会有以 name为键,输入的内容值                                //的对象存在                        return &#39;please input first name&#39;;    &#125;&#125;,&#123;    type:&#39;input&#39;,    name:&#39;secondName&#39;,    message:function(answer)&#123;        console.log(answer);        return &#39;please input second name&#39;;    &#125;&#125;,&#123;    type:&#39;confirm&#39;,    name:&#39;confirm&#39;,    message:function(answer)&#123;        console.log(answer);        return &#39;confirm input?&#39;;    &#125;&#125;],function(answers)&#123;    console.log(&#39;all answer&#39;,answers);&#125;);</code></pre><p>基于这个库，我们还可以开发各种交互式命令的小工具，非常方便。</p>]]></content>
    
    
    <categories>
      
      <category>前端项目生成工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>inquirer</tag>
      
      <tag>yeoman</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>browserSync 使用笔记</title>
    <link href="/2015/05/07/browserSync-%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <url>/2015/05/07/browserSync-%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>最近在毕设当中用到了browserSync这个工具，项目主页:<a href="http://www.browsersync.io/">http://www.browsersync.io/</a>。<br>这个工具的好处是可以在我们改变了本地静态资源即js，css，html的时候自动帮我们将资源加载进浏览器而不会刷新整个页面，这对于我们开发SPA应用的时候非常有好处，我们不需要按F5然后再进行操作跳转到那个页面去，可以节省一些时间，下面大致讲一下如何结合gulp来使用browserSync。</p><h2 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h2><pre><code class="hljs">npm install -g browser-sync</code></pre><p><strong>tips:由于browserSync还可以运行在命令韩模式下，所以最好全局安装下</strong></p><h2 id="与gulp结合使用"><a href="#与gulp结合使用" class="headerlink" title="与gulp结合使用"></a>与gulp结合使用</h2><p><strong>这里给出一个例子</strong></p><h3 id="使用stylus构建成css之后自动加载进浏览器"><a href="#使用stylus构建成css之后自动加载进浏览器" class="headerlink" title="使用stylus构建成css之后自动加载进浏览器"></a>使用stylus构建成css之后自动加载进浏览器</h3><pre><code class="hljs">var gulp=require(&#39;gulp&#39;);var browserSync=require(&#39;browser-sync&#39;).create();var stylus = require(&#39;gulp-stylus&#39;);gulp.task(&#39;stylus&#39;,function()&#123;    return gulp.src(&#39;/path/to/stylus&#39;).            pipe(stylus()).            pipe(/path/to/css).            pipe(browserSync.reload(&#123;stream:true&#125;));&#125;);gulp.task(&#39;servecss&#39;,function()&#123;    browserSync.init(&#123;        proxy:&#39;http://localhost:3000/path&#39;,        host:&#39;http://domain.com&#39;        port:80,        open:false            &#125;);    gulp.watch(&#39;/path/to/stylus&#39;,[&#39;stylus&#39;]);&#125;);</code></pre><p>在命令行执行 <code>gulp servecss</code> 之后，会在命令行显示</p><pre><code class="hljs">Proxying: http://localhost:3000Access URLs:---------------------------Local: http://localhost:80/path ##这里的path就上面设置，proxy里的pathExternal: http://domain.com:80/path---------------------------UI: http://localhost:3001Extern UI: http://domain.com:3001</code></pre><p><strong>这里的UI 是指在浏览器输入 <code>localhost:3001</code> 之后，会打开一个web的控制面板，我们在 <code>overview</code> 里面的 <code>External</code> 这里点击new tab之后会打开 <code>http://domain.com:80/path</code><br>这时这个页面就可以被browsersync注入静态资源了</strong></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>browsersync 向浏览器注入了一个browsersync的js文件，并且使用了socket.io库，当本地文件改动之后，浏览器里的客户端browsersync.js收到的数据，这样达到注入资源的目的。注入资源的时候可以用fiddler抓包看一下，会抓到更新后的静态资源。</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>browserSync</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git用subtree引入其他项目到你的项目</title>
    <link href="/2015/01/11/git%E7%94%A8subtree%E5%BC%95%E5%85%A5%E5%85%B6%E4%BB%96%E9%A1%B9%E7%9B%AE%E5%88%B0%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE/"/>
    <url>/2015/01/11/git%E7%94%A8subtree%E5%BC%95%E5%85%A5%E5%85%B6%E4%BB%96%E9%A1%B9%E7%9B%AE%E5%88%B0%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<hr><p>在使用git过程中发现要引入另一套框架，可以使用git subtree这个功能。</p><p>##1、子目录</p><p>###先要添加远程仓库##<br>    git remote add -f  子仓库名 子仓库地址</p><p>###使用subtree添加仓库到子目录中<br>    git subtree add –prefix=子目录名 子仓库名  分支    –squash</p><p>###更新子目录<br>    git subtree pull –prefix=&lt;子目录名&gt; &lt;远程仓库&gt; &lt;分支&gt; –squash<br>###把子目录的更新推送到原框架所在的仓库<br>    git subtree push –prefix=&lt;子目录名&gt;    &lt;仓库&gt;    &lt;分支&gt;</p><p>##2、从子目录读取(可选)<br>###从子仓库检出一个分支<br>    git checkout -b temp_branch &lt;子仓库&gt;/&lt;分支&gt;<br>###切回到主分支<br>    git checkout master<br>###使用git read-tree命令<br>    git read-tree –prefix=&lt;目录&gt; -u temp_branch<br><strong>命令成功之后 ‘目录’ 中就会有子目录文件的拷贝</strong></p><p>详细说明请下载<a href="http://url.cn/YGulXh">progit</a>这本中文版的git说明电子书</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
